#!/usr/bin/env python3
from __future__ import annotations
import argparse, json, math, os, sys
from datetime import datetime, timezone, timedelta
from typing import Any, Dict, Optional, Tuple, List

import requests
from scripts.orbital import (
    AU_M, MU_SUN, deg2rad, kepler_E_from_M, oe_to_rv,
    lambert_universal, sample_transfer_polyline
)

# ---- constants & config ----
AU = AU_M
MU_EARTH = 3.986004418e14
R_EARTH  = 6378137.0
G0       = 9.80665
DEFAULT_LEO_ALT_M = 500e3
RHO_ASTEROID = 2000.0
SCHEMA_VERSION = "1.3.0"
SBDB_URL = "https://ssd-api.jpl.nasa.gov/sbdb.api"

def iso_z(dt: datetime) -> str:
    return dt.astimezone(timezone.utc).replace(tzinfo=timezone.utc).isoformat().replace("+00:00","Z")

def parse_any_datetime(s: str) -> Optional[datetime]:
    if not s: return None
    s = s.strip()
    fmts = ["%Y-%b-%d %H:%M","%Y-%m-%dT%H:%M:%SZ","%Y-%m-%dT%H:%M:%S.%fZ","%Y-%m-%dT%H:%M:%S%z","%Y-%m-%d %H:%M:%S","%Y-%m-%d"]
    for f in fmts:
        try:
            dt = datetime.strptime(s, f)
            return (dt if dt.tzinfo else dt.replace(tzinfo=timezone.utc)).astimezone(timezone.utc)
        except Exception: pass
    try:
        dt = datetime.fromisoformat(s.replace("Z","+00:00"))
        return dt.astimezone(timezone.utc)
    except Exception:
        return None

# --- circular/coplanar helpers (legacy sizing still used for HUD) ---
def hohmann_delta_v_and_tof(r1_m: float, r2_m: float, mu: float = MU_SUN) -> Tuple[float, float, float, float]:
    v1 = math.sqrt(mu / r1_m); v2 = math.sqrt(mu / r2_m)
    a_t = 0.5 * (r1_m + r2_m)
    v_p = math.sqrt(mu * (2.0 / r1_m - 1.0 / a_t))
    v_a = math.sqrt(mu * (2.0 / r2_m - 1.0 / a_t))
    dv1 = abs(v_p - v1); dv2 = abs(v2 - v_a)
    tof = math.pi * math.sqrt(a_t ** 3 / mu)
    v_inf = dv1
    return dv1, dv2, tof, v_inf

def leo_escape_dv(v_inf: float, leo_alt_m: float = DEFAULT_LEO_ALT_M) -> float:
    r_park = R_EARTH + leo_alt_m
    v_circ = math.sqrt(MU_EARTH / r_park)
    v_esc = math.sqrt(2.0) * v_circ
    return math.sqrt(v_inf**2 + v_esc**2) - v_circ

def synodic_period_days(r1_m: float, r2_m: float) -> float:
    n1 = math.sqrt(MU_SUN / (r1_m ** 3)); n2 = math.sqrt(MU_SUN / (r2_m ** 3))
    if abs(n1 - n2) < 1e-15: return 1e9
    return (2.0 * math.pi / abs(n1 - n2)) / 86400.0

def roll_forward(arrival_utc: datetime, psyn_days: float, now_utc: datetime) -> Tuple[datetime, bool, int]:
    if arrival_utc > now_utc: return arrival_utc, False, 0
    if psyn_days > 1e8:
        k = math.ceil((now_utc - arrival_utc).total_seconds()/86400.0)
        return arrival_utc + timedelta(days=k), True, k
    delta_days = (now_utc - arrival_utc).total_seconds()/86400.0
    k = math.ceil(delta_days / psyn_days)
    return arrival_utc + timedelta(days=k*psyn_days), True, k

# --- input normalization ---
def flatten_neows(blob: Dict[str, Any]) -> List[Dict[str, Any]]:
    for k in ("potentially_hazardous_neos", "neos"):
        v = blob.get(k)
        if isinstance(v, list): return v
    neo = blob.get("near_earth_objects")
    if isinstance(neo, list): return neo
    if isinstance(neo, dict):
        out=[]; [out.extend(v) for v in neo.values() if isinstance(v, list)]; return out
    if isinstance(blob, list): return blob
    for k in ("data","objects"):
        v=blob.get(k)
        if isinstance(v, list): return v
    raise SystemExit("Could not find NEO list in input JSON.")

def pick_target_r2_au(neo: Dict[str, Any], default_r2_au: float) -> float:
    for key in ("orbital_data","orbit","elements"):
        d=neo.get(key)
        if isinstance(d, dict):
            a=d.get("semi_major_axis") or d.get("a") or d.get("a_AU")
            try:
                if a: return float(a)
            except Exception: pass
    return float(default_r2_au)

def get_estimated_diameter_m_bounds(neo: Dict[str, Any]):
    dmin = neo.get("estimated_diameter_m_min"); dmax = neo.get("estimated_diameter_m_max")
    if dmin is not None and dmax is not None:
        try: return float(dmin), float(dmax)
        except Exception: pass
    ed = neo.get("estimated_diameter")
    if isinstance(ed, dict):
        meters = ed.get("meters") or {}
        dmin2 = meters.get("estimated_diameter_min"); dmax2 = meters.get("estimated_diameter_max")
        try:
            if dmin2 is not None and dmax2 is not None: return float(dmin2), float(dmax2)
        except Exception: pass
    return None, None

def estimate_asteroid_mass_and_mu(neo: Dict[str, Any]):
    dmin,dmax = get_estimated_diameter_m_bounds(neo)
    if dmin is None or dmax is None: return None, None, None
    r = 0.5*(float(dmin)+float(dmax))/2.0
    vol = (4.0/3.0)*math.pi*r**3
    M = RHO_ASTEROID*vol
    mu = 6.67430e-11*M
    return r, M, mu

# --- SBDB elements ---
def fetch_sbdb_elements(sstr: str, timeout: float = 30.0) -> Optional[Dict[str, Any]]:
    try:
        r = requests.get(SBDB_URL, params={"sstr": sstr, "phys-par":"0"}, timeout=timeout)
        r.raise_for_status(); j = r.json()
    except Exception: return None
    orbit = (j.get("orbit") or {})
    elems={}
    for e in (orbit.get("elements") or []):
        nm, val = e.get("name"), e.get("value")
        if nm in ("a","e","i","om","w","ma") and val is not None:
            try: elems[nm]=float(val)
            except Exception: pass
    epoch_jd=None
    ep=orbit.get("epoch")
    if isinstance(ep, dict) and "value" in ep:
        try: epoch_jd=float(ep["value"])
        except Exception: pass
    epoch_utc=None
    if epoch_jd is not None:
        epoch_utc=(datetime(2000,1,1,tzinfo=timezone.utc)+timedelta(days=(epoch_jd-2451544.5))).isoformat().replace("+00:00","Z")
    if not elems: return None
    return {"a_AU":elems.get("a"),"e":elems.get("e"),"i_deg":elems.get("i"),
            "raan_deg":elems.get("om"),"argp_deg":elems.get("w"),"M_deg":elems.get("ma"),
            "epoch_jd":epoch_jd,"epoch_utc":epoch_utc,"source":"JPL SBDB"}

# --- simple Earth state (heliocentric, circular 1 AU; viewer-scale adequate) ---
def earth_state_circular(t_utc: datetime):
    a=AU; e=0.0; i=0.0; O=0.0; w=0.0
    n = math.sqrt(MU_SUN/(a**3))
    dt = (t_utc - datetime(2000,1,1,tzinfo=timezone.utc)).total_seconds()
    nu = (n*dt)%(2*math.pi)
    return oe_to_rv(a, e, i, O, w, nu)

# --- core per-NEO planning ---
def plan_for_neo(neo: Dict[str, Any],
                 r1_au: float, default_r2_au: float, leo_alt_m: float,
                 profile: Dict[str, Any], arrival_override: Optional[datetime],
                 roll_past: bool, now_utc: datetime, attach_elements: bool,
                 lambert_depart: Optional[datetime], lambert_tof_days: Optional[float]) -> Dict[str, Any]:

    r2_au = pick_target_r2_au(neo, default_r2_au)
    r1_m, r2_m = r1_au*AU, r2_au*AU

    # legacy Hohmann sizing (for HUD/back-compat fields)
    dv1, dv2, tof_sec, v_inf = hohmann_delta_v_and_tof(r1_m, r2_m)
    dv_leo = leo_escape_dv(v_inf, leo_alt_m)
    total_dv = dv_leo + dv2

    # arrival time (from snapshot if present, else now+TOF)
    arrival_dt = None
    if arrival_override:
        arrival_dt = arrival_override
    else:
        ca = neo.get("close_approach") or neo.get("close_approach_data")
        if isinstance(ca, dict):
            arrival_dt = parse_any_datetime(ca.get("date_full") or ca.get("close_approach_date_full") or ca.get("date"))
        elif isinstance(ca, list) and ca:
            earth_first = next((e for e in ca if e.get("orbiting_body")=="Earth"), ca[0])
            arrival_dt = parse_any_datetime(earth_first.get("date_full") or earth_first.get("close_approach_date_full") or earth_first.get("close_approach_date"))
    if arrival_dt is None:
        arrival_dt = now_utc + timedelta(seconds=tof_sec)

    psyn_days = synodic_period_days(r1_m, r2_m)
    rolled=False; k_roll=0
    if roll_past:
        arrival_dt, rolled, k_roll = roll_forward(arrival_dt, psyn_days, now_utc)
    depart_dt = arrival_dt - timedelta(seconds=tof_sec)

    # asteroid on-orbit suggestion (unchanged)
    R_ast, M_ast, mu_ast = estimate_asteroid_mass_and_mu(neo)
    if R_ast and mu_ast and mu_ast>0:
        alt=max(3*R_ast, 1000.0); r_orb=R_ast+alt; v_c=math.sqrt(mu_ast/r_orb); T=(2*math.pi*r_orb/v_c) if v_c>0 else None
        suggested = {"radius_m":r_orb,"altitude_m":alt,"circular_speed_m_s":v_c,"period_s":T,"note":"alt >= max(3R,1 km); density 2 g/cc assumed"}
    else:
        suggested = {"radius_m":None,"altitude_m":1000.0,"circular_speed_m_s":None,"period_s":None,"note":"Diameter missing; default >=1 km."}

    plan: Dict[str, Any] = {
        "schema_version": SCHEMA_VERSION,
        "profile": profile["name"],
        "r1_AU": r1_au, "r2_AU": r2_au,
        "tof_days": tof_sec/86400.0,
        "synodic_days": psyn_days,
        "arrival_utc": iso_z(arrival_dt), "departure_utc": iso_z(depart_dt),
        "rolled_forward": rolled, "roll_periods_added": k_roll,
        "dv_depart_heliocentric_m_s": dv1,
        "dv_arrive_heliocentric_m_s": dv2,
        "v_inf_m_s": v_inf,
        "dv_from_LEO_m_s": dv_leo, "dv_total_m_s": total_dv,
        "leo_altitude_m": leo_alt_m,
        "spacecraft_mass_kg": profile["m0_kg"], "Isp_s": profile["Isp_s"],
        "propellant_estimate_kg": (profile["m0_kg"] - profile["m0_kg"]/math.exp(total_dv/(profile["Isp_s"]*G0))) if total_dv>0 and profile["Isp_s"]>0 else 0.0,
        "suggested_orbit": suggested,
        "notes": "Hohmann for sizing; Lambert block provides true rendezvous when present."
    }

    # optional: attach SBDB elements for the target
    elems=None
    if attach_elements:
        sstr = neo.get("neo_reference_id") or neo.get("neo_reference") or neo.get("id") or neo.get("name")
        if sstr:
            elems = fetch_sbdb_elements(str(sstr))
            if elems and all(elems.get(k) is not None for k in ("a_AU","e","i_deg","raan_deg","argp_deg","M_deg")):
                plan["elements"] = {
                    "a_AU": float(elems["a_AU"]), "e": float(elems["e"]),
                    "i_deg": float(elems["i_deg"]), "raan_deg": float(elems["raan_deg"]),
                    "argp_deg": float(elems["argp_deg"]), "M_deg": float(elems["M_deg"]),
                    "epoch_utc": elems.get("epoch_utc"), "source": elems.get("source","JPL SBDB")
                }

    # ---- Lambert (true rendezvous) if requested ----
    if lambert_depart and lambert_tof_days:
        t1 = lambert_depart.astimezone(timezone.utc)
        t2 = t1 + timedelta(days=float(lambert_tof_days))

        # r1 = Earth heliocentric state at t1 (circular 1 AU), r2 = target state at t2
        r1, vE = earth_state_circular(t1)
        if elems:
            # propagate target from its epoch to t2 (Kepler E → ν)
            a_m = elems["a_AU"]*AU_M; e = elems["e"]
            i = deg2rad(elems["i_deg"]); O = deg2rad(elems["raan_deg"]); w = deg2rad(elems["argp_deg"])
            # epoch handling (SBDB epoch ≈ TDB → close enough here)
            t0 = t2  # default to arrival if epoch missing
            if elems.get("epoch_utc"):
                t0 = datetime.fromisoformat(elems["epoch_utc"].replace("Z","+00:00"))
            n = math.sqrt(MU_SUN/(a_m**3))
            dt = (t2 - t0).total_seconds()
            M = deg2rad(elems["M_deg"]) + n*dt
            E = kepler_E_from_M(M, e)
            nu = 2*math.atan2(math.sqrt(1+e)*math.sin(E/2), math.sqrt(1-e)*math.cos(E/2))
            r2, v_ast = oe_to_rv(a_m, e, i, O, w, nu)
        else:
            # fallback: circular target at a=r2_au in ecliptic plane
            a_m = r2_au*AU_M; e=0.0; i=0.0; O=0.0; w=0.0
            n = math.sqrt(MU_SUN/(a_m**3))
            dt = (t2 - datetime(2000,1,1,tzinfo=timezone.utc)).total_seconds()
            nu = (n*dt)%(2*math.pi)
            r2, v_ast = oe_to_rv(a_m, e, i, O, w, nu)

        v1, v2 = lambert_universal(r1, r2, float(lambert_tof_days)*86400.0, MU_SUN, prograde=True)
        dv_depart = float(np.linalg.norm(v1 - vE))
        dv_arrive = float(np.linalg.norm(v2 - v_ast))
        plan["lambert"] = {
            "t_depart_utc": iso_z(t1),
            "t_arrive_utc": iso_z(t2),
            "tof_days": float(lambert_tof_days),
            "dv_depart_m_s": dv_depart,
            "dv_arrive_m_s": dv_arrive
        }
        # polyline for the viewer to draw
        plan["lambert_polyline_xy_au"] = sample_transfer_polyline(r1, v1, float(lambert_tof_days)*86400.0, n=220)

    return plan

# --- IO/CLI ---
def load_json(p: str) -> Dict[str, Any]:
    with open(p,"r",encoding="utf-8") as f: return json.load(f)
def write_json(obj: Dict[str, Any], p: str) -> None:
    os.makedirs(os.path.dirname(p), exist_ok=True)
    with open(p,"w",encoding="utf-8") as f: json.dump(obj, f, indent=2)

def derive_default_output(in_path: str) -> str:
    d, base = os.path.split(in_path); name,_ = os.path.splitext(base)
    return os.path.join(d, f"{name}_intercept.json")

def build_profile(name: str, m0_kg: float, isp_s: float) -> Dict[str, Any]:
    return {"name": name, "m0_kg": float(m0_kg), "Isp_s": float(isp_s)}

def main():
    parser = argparse.ArgumentParser(description="Compute intercept plans for hazardous NEOs (Lambert-enabled).")
    parser.add_argument("--input", default=os.getenv("OUT_FILE", "data/hazardous_neos/latest.json"))
    parser.add_argument("--output", default=None)
    parser.add_argument("--r1-au", type=float, default=1.0)
    parser.add_argument("--r2-au", type=float, default=None)
    parser.add_argument("--leo-km", type=float, default=500.0)
    parser.add_argument("--arrive-utc", type=str, default=None)
    parser.add_argument("--roll-past", action="store_true")
    parser.add_argument("--profile", choices=["neosurveyor","custom"], default="neosurveyor")
    parser.add_argument("--m0-kg", type=float, default=1300.0)
    parser.add_argument("--Isp-s", type=float, default=230.0)
    parser.add_argument("--elements", action="store_true", help="Attach SBDB elements for inclined geometry.")
    # Lambert (true rendezvous)
    parser.add_argument("--lambert", action="store_true", help="Compute a single Lambert transfer.")
    parser.add_argument("--depart-utc", type=str, help="Lambert departure UTC (ISO).")
    parser.add_argument("--tof-days", type=float, help="Lambert time of flight in days.")

    args = parser.parse_args()
    now_utc = datetime.now(timezone.utc)
    prof = build_profile("neosurveyor", 1300.0, 230.0) if args.profile=="neosurveyor" else build_profile("custom", args.m0_kg, args.Isp_s)
    out_path = args.output or derive_default_output(args.input)
    r1_au = float(args.r1_au); default_r2_au = float(args.r2_au) if args.r2_au else 1.0
    leo_alt_m = float(args.leo_km)*1e3
    arrival_override = parse_any_datetime(args.arrive_utc) if args.arrive_utc else None
    lambert_depart = parse_any_datetime(args.depart_utc) if args.lambert and args.depart_utc else None
    lambert_tof_days = float(args.tof_days) if args.lambert and args.tof_days else None

    if args.lambert and (lambert_depart is None or lambert_tof_days is None):
        print("ERROR: --lambert requires both --depart-utc and --tof-days", file=sys.stderr); sys.exit(2)

    data = load_json(args.input)
    neos = flatten_neows(data)

    out_neos: List[Dict[str, Any]] = []
    for neo in neos:
        try:
            plan = plan_for_neo(
                neo=neo, r1_au=r1_au, default_r2_au=default_r2_au, leo_alt_m=leo_alt_m,
                profile=prof, arrival_override=arrival_override, roll_past=args.roll_past,
                now_utc=now_utc, attach_elements=args.elements,
                lambert_depart=lambert_depart, lambert_tof_days=lambert_tof_days
            )
            neo_out = dict(neo); neo_out["intercept_plan"] = plan; out_neos.append(neo_out)
        except Exception as e:
            out_neos.append({"name": neo.get("name"), "neo_reference_id": neo.get("neo_reference_id") or neo.get("id"),
                             "error": f"{type(e).__name__}: {e}"})

    out = {
        "date_utc": now_utc.date().isoformat(),
        "snapshot_utc": iso_z(now_utc),
        "count": len(out_neos),
        "schema": {"version": SCHEMA_VERSION, "source": "neo_intercept_planner.py",
                   "assumptions": {"circular_coplanar": True, "density_kg_m3": RHO_ASTEROID, "leo_alt_km": leo_alt_m/1e3}},
        "potentially_hazardous_neos": out_neos
    }
    write_json(out, out_path)
    print(f"Wrote intercept plans → {out_path}")

if __name__ == "__main__":
    main()
